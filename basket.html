<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Pharma Conveyor Simulation V17 (Load-Balanced Entry Algorithm)</title>
    <style>
        /* --- CSS: LAYOUT AND STYLING (V16/V17) --- */
        body {
            font-family: 'Consolas', monospace;
            margin: 0; 
            padding: 10px;
            background-color: #1a1a1a;
            color: #e0e0e0;
            overflow-x: hidden;
        }
        .container {
            width: 100%; 
            max-width: 100%;
            margin: 0 auto;
            border: 1px solid #444;
            padding: 15px;
            background-color: #252526;
            border-radius: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h2 { color: #2196f3; border-bottom: 1px solid #444; padding-bottom: 5px; width: 100%; text-align: center; margin-bottom: 20px; }
        .controls { padding: 10px 0; margin-bottom: 20px; border-bottom: 1px solid #333; width: 100%; text-align: center; }
        button { padding: 8px 15px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-weight: bold; transition: background-color 0.3s; margin: 0 5px; }
        button:hover { background-color: #45a049; }
        .info-display { display: flex; justify-content: space-around; width: 100%; margin-top: 10px; font-size: 0.9em; }
        .info-display p { margin: 0; }
        .info-display strong { color: #ffeb3b; }
        .load-info { color: #2196f3; } /* V17: Highlight Load Info */

        /* --- System Visualization: V17 Grid Alignment --- */
        .system-viz {
            display: grid;
            grid-template-columns: 80px 1fr 10px 1fr 10px 1fr 10px 80px; 
            grid-template-rows: 80px 10px 100px;
            gap: 0px;
            position: relative;
            width: 98%; 
            min-width: 700px;
            height: 250px;
            background-color: #1a1a1a; 
            border: 1px solid #444;
            overflow: visible;
        }
        
        .main-horizontal-track { grid-row: 2 / 3; grid-column: 1 / 9; background-color: #555; position: relative; height: 100%; align-self: center; }
        
        .junction { grid-row: 1 / 4; background-color: #6d6d6d; width: 100%; justify-self: center; z-index: 1; opacity: 0.5; }
        #junction-A { grid-column: 3 / 4; }
        #junction-B { grid-column: 5 / 6; }
        #junction-C { grid-column: 7 / 8; }

        #entry-point { grid-row: 2 / 3; grid-column: 1 / 2; align-self: center; justify-self: center; color: #2196f3; font-weight: bold; z-index: 10; }
        #exit-point { grid-row: 2 / 3; grid-column: 8 / 9; align-self: center; justify-self: center; color: #2196f3; font-weight: bold; z-index: 10; }

        /* Station/Waiting Containers - ‡∏à‡∏±‡∏î‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á 1fr ‡πÅ‡∏•‡∏∞‡∏ä‡∏¥‡∏î‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á‡∏ä‡πà‡∏≠‡∏á‡∏ô‡∏±‡πâ‡∏ô */
        .station-container, .waiting-container { display: flex; justify-content: flex-end; position: relative; }
        #waiting-A-cont { grid-column: 2 / 3; grid-row: 1 / 2; align-items: flex-end; padding-right: 15px; } 
        #waiting-B-cont { grid-column: 4 / 5; grid-row: 1 / 2; align-items: flex-end; padding-right: 15px; }
        #waiting-C-cont { grid-column: 6 / 7; grid-row: 1 / 2; align-items: flex-end; padding-right: 15px; }
        
        #station-A-cont { grid-column: 2 / 3; grid-row: 3 / 4; align-items: flex-start; padding-right: 15px; }
        #station-B-cont { grid-column: 4 / 5; grid-row: 3 / 4; align-items: flex-start; padding-right: 15px; }
        #station-C-cont { grid-column: 6 / 7; grid-row: 3 / 4; align-items: flex-start; padding-right: 15px; }

        .station { width: 80px; height: 50px; background-color: #388e3c; border: 2px solid #2e7d32; border-radius: 4px; display: flex; flex-direction: column; justify-content: center; align-items: center; font-weight: bold; color: white; transition: background-color 0.3s; z-index: 10; position: relative; }
        .station.busy { background-color: #d32f2f; border-color: #c62828; }
        .station-info { font-size: 0.8em; color: #ccc; }
        .worker { position: absolute; font-size: 1.5em; color: #4CAF50; top: -20px; right: 5px; }
        
        .waiting-zone { width: 100px; height: 50px; background-color: #333; border: 1px dashed #777; border-radius: 3px; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.7em; color: #ffeb3b; z-index: 10; }
        .queue-content { font-size: 0.9em; margin-top: 2px; }

        .basket { position: absolute; width: 30px; height: 20px; background-color: #ffeb3b; border: 1px solid #fbc02d; border-radius: 3px; color: black; font-size: 0.7em; font-weight: bold; display: flex; justify-content: center; align-items: center; transition: transform 0.5s linear, opacity 0.3s; z-index: 30; box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); pointer-events: none; }
        .basket.exiting { background-color: #f9a825; } 

        .log-area { height: 180px; overflow-y: scroll; background: #1c1c1c; padding: 10px; border-radius: 4px; margin-top: 20px; font-size: 0.85em; width: 100%; }
        .log-area p { margin: 2px 0; white-space: nowrap; }
        .log-move { color: #64b5f6; }
        .log-wait { color: #ffeb3b; }
        .log-signal { color: #81c784; }
        .log-halt { color: #ff5252; font-weight: bold; }
        .log-entry { color: #00bcd4; }
        .log-exit { color: #f9a825; font-weight: bold; } 
        .log-deny { color: #2196f3; font-weight: bold; } /* V17: New color for Entry Denied */

    </style>
</head>
<body>

    <div class="container">
        <h2>Pharma Production Line Simulation V17 ( Load-Balanced Entry Algorithm)</h2>
        <div class="controls">
            <button onclick="startSimulation()">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°/‡∏£‡∏±‡∏ô‡∏ï‡πà‡∏≠</button>
            <button onclick="stopSimulation()">‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
            <button onclick="resetSimulation()">üîÑ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö</button>
            <div class="info-display">
                <p><strong>Entry Queue:</strong> <span id="entry-queue-display"></span></p>
                <p><strong>Active Baskets:</strong> <span id="active-baskets-count">0</span></p>
                <p><strong>Load A/B/C:</strong> <strong class="load-info"><span id="load-display">0/0/0</span></strong></p>
            </div>
        </div>

        <div class="system-viz" id="system-viz">
            <div class="main-horizontal-track" id="main-horizontal-track"></div>

            <div id="entry-point">‚¨ÖÔ∏è Entry</div>
            <div id="exit-point">Exit ‚û°Ô∏è</div>

            <div class="junction" id="junction-A"></div>
            <div class="junction" id="junction-B"></div>
            <div class="junction" id="junction-C"></div>

            <div class="station-container" id="station-A-cont">
                <div class="station" id="station-A">A<div class="worker">üßë‚Äçüè≠</div><div class="station-info">‡∏ô‡∏≤‡∏¢‡πÄ‡∏≠</div></div>
            </div>
            <div class="station-container" id="station-B-cont">
                <div class="station" id="station-B">B<div class="worker">üßë‚Äçüè≠</div><div class="station-info">‡∏ô‡∏≤‡∏¢‡∏ö‡∏µ</div></div>
            </div>
            <div class="station-container" id="station-C-cont">
                <div class="station" id="station-C">C<div class="worker">üßë‚Äçüè≠</div><div class="station-info">‡∏ô‡∏≤‡∏¢‡∏ã‡∏µ</div></div>
            </div>

            <div class="waiting-container" id="waiting-A-cont">
                <div class="waiting-zone" id="waiting-A">‡∏à‡∏∏‡∏î‡∏û‡∏±‡∏Å‡∏£‡∏≠ A<div class="queue-content"></div></div>
            </div>
            <div class="waiting-container" id="waiting-B-cont">
                <div class="waiting-zone" id="waiting-B">‡∏à‡∏∏‡∏î‡∏û‡∏±‡∏Å‡∏£‡∏≠ B<div class="queue-content"></div></div>
            </div>
            <div class="waiting-container" id="waiting-C-cont">
                <div class="waiting-zone" id="waiting-C">‡∏à‡∏∏‡∏î‡∏û‡∏±‡∏Å‡∏£‡∏≠ C<div class="queue-content"></div></div>
            </div>
        </div>
        
        <div class="log-area" id="log-area">
            <p style="color: #ccc;">--- Log Start ---</p>
        </div>
    </div>
    
    <script>
        // --- JAVASCRIPT: LOGIC AND ANIMATION CONTROL (V17) ---
        // constants
        const BASKET_WIDTH = 30;
        const BASKET_SAFE_GAP = 10; 
        const TRAVEL_SPEED = 30; 
        const TICK_INTERVAL = 400; 
        const ENTRY_CLEARANCE = 80; 
        const STATION_PROCESS_TIME = 1.0; 

        function getInitialState() {
            return {
                stations: {
                    'A': { busy: false, basket: null, time: STATION_PROCESS_TIME, finishTime: 0, side: 'bottom', maxLoad: 2 }, // V17: maxLoad = 1 Station + 1 Waiting
                    'B': { busy: false, basket: null, time: STATION_PROCESS_TIME, finishTime: 0, side: 'bottom', maxLoad: 2 },
                    'C': { busy: false, basket: null, time: STATION_PROCESS_TIME, finishTime: 0, side: 'bottom', maxLoad: 2 },
                },
                waitingZones: {
                    'Waiting_A': { queue: [], capacity: 1, side: 'top' },
                    'Waiting_B': { queue: [], capacity: 1, side: 'top' },
                    'Waiting_C': { queue: [], capacity: 1, side: 'top' },
                },
                entryQueue: [
                    // Added more baskets for better load testing
                    { id: 1, route: ['A', 'B'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 2, route: ['A', 'C'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 3, route: ['B', 'C', 'A'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 4, route: ['A', 'B'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 5, route: ['C', 'A'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 6, route: ['A', 'B', 'C'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 7, route: ['B'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 8, route: ['C'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 9, route: ['A'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                    { id: 10, route: ['B'], nextIndex: 0, location: 'Entry Point', x_position: 0 },
                ],
                activeBaskets: [],
                tick: 0,
                interval: null,
                junctionXPositions: {},
                mainTrackY: 0,
                entryX: 0,
                exitX: 0,
                currentLoad: { 'A': 0, 'B': 0, 'C': 0 } // V17: Track current load
            };
        }

        let state = getInitialState();

        // --- Helper Functions (Same as V16) ---
        function getRemainingRouteString(basket) {
            const total = basket.route.length;
            const completed = basket.nextIndex;
            const remaining = total - completed;
            
            if (remaining <= 0) return `‚úÖ FINISHED (Exit)`;
            
            const routePart = basket.route.slice(basket.nextIndex).join('‚Üí');
            return `‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ${remaining} ‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ: [${routePart}]`;
        }

        function getRouteString(basket) {
            return basket.route.map((r, i) => i === basket.nextIndex ? `**${r}**` : r).join('‚Üí');
        }

        function log(message, type = 'entry', basketId = null) {
            const logArea = document.getElementById('log-area');
            const p = document.createElement('p');
            p.className = 'log-' + type;
            let logText = `[T${state.tick}] `;
            if (basketId) {
                const basket = state.activeBaskets.find(b => b.id === basketId);
                const routeInfo = basket ? `(${getRemainingRouteString(basket)})` : '(Finished)';
                logText += `B${basketId} ${routeInfo}: ${message}`;
            } else {
                logText += message;
            }
            p.innerHTML = logText;
            logArea.prepend(p);
            while (logArea.children.length > 50) {
                logArea.removeChild(logArea.lastChild);
            }
        }

        function getBasketElement(basketId) {
            let el = document.getElementById(`basket-${basketId}`);
            if (!el) {
                el = document.createElement('div');
                el.id = `basket-${basketId}`;
                el.className = 'basket';
                el.textContent = `B${basketId}`;
                document.getElementById('system-viz').appendChild(el);
            }
            return el;
        }

        function getElementCenterPosition(elementId) {
            const el = document.getElementById(elementId);
            if (!el) return { x: 0, y: 0, width: 0, height: 0 };
            const rect = el.getBoundingClientRect();
            const viz_rect = document.getElementById('system-viz').getBoundingClientRect();
            return {
                x: rect.left - viz_rect.left + rect.width / 2,
                y: rect.top - viz_rect.top + rect.height / 2,
                width: rect.width,
                height: rect.height
            };
        }

        function cachePositions() {
            const main_track_pos = getElementCenterPosition('main-horizontal-track');
            state.mainTrackY = main_track_pos.y;
            state.entryX = getElementCenterPosition('entry-point').x;
            state.exitX = getElementCenterPosition('exit-point').x;
            
            const junctionA_pos = getElementCenterPosition('junction-A');
            const junctionB_pos = getElementCenterPosition('junction-B');
            const junctionC_pos = getElementCenterPosition('junction-C');
            
            state.junctionXPositions = {
                'A': junctionA_pos.x,
                'B': junctionB_pos.x,
                'C': junctionC_pos.x,
            };

            state.entryQueue.forEach(basket => {
                 if (basket.location === 'Entry Point' || basket.x_position === 0) {
                    basket.x_position = state.entryX - 40;
                }
            });
        }

        function getStationCharFromLocation(locationStr) {
            const match = locationStr.match(/[ABC]$/);
            return match ? match[0] : null;
        }

        function updateBasketPosition(basket) {
            const el = getBasketElement(basket.id);
            let targetX = 0, targetY = 0;
            const halfW = BASKET_WIDTH / 2;
            const halfH = 10;
            const { mainTrackY, junctionXPositions } = state;
            
            targetY = mainTrackY;
            el.classList.remove('exiting'); 

            if (basket.location === 'Entry Point') {
                targetX = basket.x_position;
                el.style.opacity = '0';
            } else if (basket.location === 'On_Main_Track' || basket.location === 'Exiting') {
                targetX = basket.x_position;
                targetY = mainTrackY; 
                el.style.opacity = '1';
                if (basket.location === 'Exiting') {
                    el.classList.add('exiting'); 
                }
            } else if (basket.location === 'Finished') {
                targetX = state.exitX + 40;
                targetY = mainTrackY;
                el.style.opacity = '0';
            } else {
                const stationChar = getStationCharFromLocation(basket.location);
                if (stationChar) {
                    const stationPos = getElementCenterPosition(`station-${stationChar}`);
                    const waitingPos = getElementCenterPosition(`waiting-${stationChar}`);

                    if (basket.location.includes('Station')) {
                        targetX = stationPos.x;
                        targetY = stationPos.y;
                    } else if (basket.location.includes('Waiting')) {
                        targetX = waitingPos.x;
                        targetY = waitingPos.y;
                    } else if (basket.location.includes('Spur')) {
                        targetX = junctionXPositions[stationChar];
                        
                        if (basket.location.includes('To_Station') || basket.location.includes('From_Waiting')) {
                            targetY = stationPos.y; 
                        } else if (basket.location.includes('To_Waiting') || basket.location.includes('From_Station')) {
                            targetY = waitingPos.y;
                        } else {
                            targetY = mainTrackY; 
                        }
                    }
                    el.style.opacity = '1';
                } else {
                    targetX = basket.x_position || state.entryX;
                    targetY = mainTrackY;
                    el.style.opacity = '1';
                }
            }
            el.style.transform = `translate(${targetX - halfW}px, ${targetY - halfH}px)`;
        }

        // --- Core Movement Logic (V16 - Collision Check remains) ---
        function moveBasketsOnMainTrack() {
            const basketsOnMainTrack = state.activeBaskets
                .filter(b => b.location === 'On_Main_Track' || b.location === 'Exiting')
                .sort((a, b) => a.x_position - b.x_position);
            
            let prevBasketX = state.exitX + 100; 
            
            for (let i = basketsOnMainTrack.length - 1; i >= 0; i--) {
                const basket = basketsOnMainTrack[i];
                let targetName = basket.route[basket.nextIndex];
                
                let rawTargetX = 0;
                if (basket.location === 'Exiting') {
                    rawTargetX = state.exitX + 40; 
                } else {
                    rawTargetX = targetName ? state.junctionXPositions[targetName] : state.exitX;
                }
                
                // 1. Collision Check
                const maxAllowedX = prevBasketX - BASKET_WIDTH - BASKET_SAFE_GAP;
                
                // 2. Calculate next position based on speed and target
                let nextX = Math.min(basket.x_position + TRAVEL_SPEED, rawTargetX);
                
                // 3. Apply Collision Constraint
                if (nextX > maxAllowedX) {
                    nextX = maxAllowedX;
                }

                // 4. Finalize Movement for this tick
                basket.x_position = nextX;
                prevBasketX = basket.x_position;
                
                // 5. Junction Arrival Check
                if (basket.location === 'On_Main_Track' && Math.abs(basket.x_position - rawTargetX) <= TRAVEL_SPEED) {
                    basket.x_position = rawTargetX; 
                    
                    if (targetName) {
                        decideAtJunction(basket, targetName);
                    } else {
                        // Should be caught by releaseToMainTrackOrExit
                        basket.location = 'Exiting';
                    }
                } else if (basket.location === 'Exiting' && basket.x_position >= state.exitX + 40) {
                     basket.location = 'Finished';
                     log(`Basket ${basket.id} successfully Exited the system.`, 'exit', basket.id);
                }
            }
        }
        
        // --- Junction/Release Logic (Same as V16) ---
        function releaseToMainTrackOrExit(basket) {
            const stationChar = getStationCharFromLocation(basket.location);
            const junctionX = state.junctionXPositions[stationChar];
            
            const nextBasketOnTrack = state.activeBaskets
                .filter(b => b.location === 'On_Main_Track' || b.location === 'Exiting')
                .find(b => b.x_position > junctionX); 
            
            const isClear = !nextBasketOnTrack || (nextBasketOnTrack.x_position > junctionX + BASKET_WIDTH + BASKET_SAFE_GAP);

            if (isClear) {
                // Route Complete: Send to Exit
                if (basket.nextIndex >= basket.route.length) {
                    basket.location = 'Exiting';
                    basket.x_position = junctionX; 
                    log(`ROUTE COMPLETE! Placing B${basket.id} on main track for final Exit.`, 'exit', basket.id);
                } else {
                    // Not finished: Send back to Main Track
                    basket.location = 'On_Main_Track';
                    basket.x_position = junctionX; 
                    log(`SUCCESS: Released B${basket.id} onto Main Track.`, 'move', basket.id);
                }
            } else {
                log(`HALT: Main Track at Junction ${stationChar} is blocked. Waiting for clearance.`, 'halt', basket.id);
                
                basket.nextIndex--; 
                basket.location = `In_Station_${stationChar}`; 
                
                const station = state.stations[stationChar];
                station.finishTime = Date.now() + TICK_INTERVAL + 100;
            }
        }

        function decideAtJunction(basket, targetName) {
            const station = state.stations[targetName];
            const waitingZone = state.waitingZones[`Waiting_${targetName}`];
            
            if (!station.busy) {
                basket.location = `On_Spur_To_Station_${targetName}`;
                log(`Entering Spur to Station ${targetName}.`, 'signal', basket.id);

                setTimeout(() => {
                    station.busy = true;
                    station.basket = basket.id;
                    station.finishTime = Date.now() + (station.time * 5000);
                    basket.location = `In_Station_${targetName}`;
                }, 100); 
            } else if (waitingZone.queue.length < waitingZone.capacity) {
                basket.location = `On_Spur_To_Waiting_${targetName}`;
                log(`Station ${targetName} busy. Entering Spur to WAITING ZONE.`, 'wait', basket.id);

                setTimeout(() => {
                    waitingZone.queue.push(basket);
                    basket.location = `Waiting_${targetName}`;
                }, 100); 
            } else {
                log(`Junction ${targetName} full. SKIPPING to next target.`, 'move', basket.id);
                
                basket.nextIndex++;
                const nextTargetName = basket.route[basket.nextIndex];
                
                const nextTargetX = nextTargetName ? state.junctionXPositions[nextTargetName] : state.exitX;
                basket.x_position = nextTargetX; 
            }
        }
        
        // --- V17: Main Logic Update ---
        function calculateCurrentLoad() {
            const load = { 'A': 0, 'B': 0, 'C': 0 };
            
            // 1. Load from Stations and Waiting Zones
            for (const name of ['A', 'B', 'C']) {
                if (state.stations[name].busy) {
                    load[name]++;
                }
                load[name] += state.waitingZones[`Waiting_${name}`].queue.length;
            }
            
            // 2. Load from Active Baskets (On Main Track / Spurs)
            for (const basket of state.activeBaskets) {
                if (basket.location === 'On_Main_Track' || basket.location.includes('Spur')) {
                    const targetName = basket.route[basket.nextIndex];
                    if (targetName) {
                        load[targetName]++;
                    }
                }
            }
            state.currentLoad = load;
        }

        function simulateTick() {
            state.tick++;
            const now = Date.now();
            
            // V17: Calculate Load at the start of the tick
            calculateCurrentLoad();
            
            // 1. Process Baskets on Main Track (Movement & Junction Decision)
            moveBasketsOnMainTrack();

            // 2. Process Stations/Waiting Zones (Same as V16)
            for (const name in state.stations) {
                const station = state.stations[name];
                const waitingZone = state.waitingZones[`Waiting_${name}`];

                // A) Finish Processing
                if (station.busy && station.finishTime <= now) {
                    const finishedBasket = state.activeBaskets.find(b => b.id === station.basket);
                    
                    if (finishedBasket) {
                        finishedBasket.nextIndex++; 
                        releaseToMainTrackOrExit(finishedBasket); 
                        
                        if (finishedBasket.location !== `In_Station_${name}`) {
                             station.busy = false;
                             station.basket = null;
                        }
                    }
                }

                // B) Release from Waiting to Station
                if (!station.busy && waitingZone.queue.length > 0) {
                    const nextBasketInQueue = waitingZone.queue.shift();
                    
                    nextBasketInQueue.location = `On_Spur_From_Waiting_${name}`; 
                    log(`Waiting Zone ${name} released B${nextBasketInQueue.id} to Spur to Station.`, 'move', nextBasketInQueue.id);

                    setTimeout(() => {
                        station.busy = true;
                        station.basket = nextBasketInQueue.id;
                        station.finishTime = Date.now() + (station.time * 1000);
                        nextBasketInQueue.location = `In_Station_${name}`;
                        log(`Entered Station ${name} from Waiting.`, 'signal', nextBasketInQueue.id);
                    }, 100);
                }
            }

            // 3. Release from Entry Point (V17: Load-Balanced Entry Logic)
            const basketsOnTrack = state.activeBaskets.filter(b => b.location === 'On_Main_Track' || b.location === 'Exiting');
            let minX = state.exitX + 100;
            if (basketsOnTrack.length > 0) {
                minX = basketsOnTrack.reduce((acc, b) => Math.min(acc, b.x_position), minX);
            }
            
            const requiredClearance = state.entryX + BASKET_WIDTH + BASKET_SAFE_GAP;

            if (state.entryQueue.length > 0 && minX > requiredClearance) {
                const newBasket = state.entryQueue[0];
                const nextTarget = newBasket.route[0];
                const maxLoad = state.stations[nextTarget].maxLoad;
                
                // V17: CHECK LOAD BALANCE
                if (state.currentLoad[nextTarget] < maxLoad) {
                    state.entryQueue.shift(); // Remove from queue
                    newBasket.location = 'On_Main_Track';
                    newBasket.x_position = state.entryX; 
                    log(`B${newBasket.id} RELEASED. Target ${nextTarget} Load: ${state.currentLoad[nextTarget]}/${maxLoad}.`, 'entry', newBasket.id);
                    state.activeBaskets.push(newBasket);
                } else {
                    // DENY ENTRY
                    log(`ENTRY DENIED: Target ${nextTarget} is full (Load: ${state.currentLoad[nextTarget]}/${maxLoad}). Waiting for clearance.`, 'deny', newBasket.id);
                }
            }

            state.activeBaskets = state.activeBaskets.filter(b => b.location !== 'Finished');

            updateUI();

            if (state.entryQueue.length === 0 && state.activeBaskets.length === 0 && !Object.values(state.stations).some(s => s.busy)) {
                log('üéâ All baskets finished! Simulation stopped.', 'signal');
                stopSimulation();
            }
        }

        // --- UI Update and Control Functions ---
        function updateUI() {
            document.getElementById('entry-queue-display').textContent = state.entryQueue.map(b => `B${b.id}`).join(', ');
            document.getElementById('active-baskets-count').textContent = state.activeBaskets.length;
            
            const loadA = state.currentLoad['A'] || 0;
            const loadB = state.currentLoad['B'] || 0;
            const loadC = state.currentLoad['C'] || 0;
            const max = state.stations['A'].maxLoad;
            document.getElementById('load-display').textContent = `${loadA}/${loadB}/${loadC} (Max: ${max})`;

            for (const name in state.stations) {
                const station = state.stations[name];
                const stationEl = document.getElementById(`station-${name}`);
                const waitingZone = state.waitingZones[`Waiting_${name}`];

                if (station.busy) {
                    stationEl.classList.add('busy');
                    stationEl.querySelector('.station-info').textContent = `B${station.basket}`;
                } else {
                    stationEl.classList.remove('busy');
                    stationEl.querySelector('.station-info').textContent = `‡∏ô‡∏≤‡∏¢${name === 'A' ? '‡πÄ‡∏≠' : name === 'B' ? '‡∏ö‡∏µ' : '‡∏ã‡∏µ'}`;
                }
                
                const queueList = waitingZone.queue.map(b => `B${b.id}`).join(', ');
                document.getElementById(`waiting-${name}`).querySelector('.queue-content').textContent = `(${waitingZone.queue.length}/${waitingZone.capacity}) ${queueList}`;
            }
            
            document.querySelectorAll('.basket').forEach(el => {
                const id = parseInt(el.id.replace('basket-', ''), 10);
                const inActive = state.activeBaskets.some(b => b.id === id);
                const inEntry = state.entryQueue.some(b => b.id === id);
                if (!inActive && !inEntry) el.remove();
            });

            state.activeBaskets.forEach(basket => updateBasketPosition(basket));
        }

        function startSimulation() {
            if (state.interval) return;
            log('Simulation started (LOAD-BALANCED ENTRY MODE).', 'entry');
            cachePositions(); 
            state.interval = setInterval(simulateTick, TICK_INTERVAL);
            simulateTick();
        }

        function stopSimulation() {
            if (state.interval) {
                clearInterval(state.interval);
                state.interval = null;
                log('Simulation paused.', 'halt');
            }
        }

        function resetSimulation() {
            stopSimulation();
            document.querySelectorAll('.basket').forEach(el => el.remove());
            document.getElementById('log-area').innerHTML = '<p style="color: #ccc;">--- Log Start ---</p>';
            state = getInitialState();
            cachePositions();
            updateUI();
            log('System reset successful. Press START to run simulation.', 'entry');
        }

        document.addEventListener('DOMContentLoaded', () => {
             cachePositions();
             updateUI();
             log('System initialized. Press START to run simulation.', 'entry');
        });

        window.addEventListener('resize', () => {
            cachePositions();
        });

    </script>
</body>
</html>